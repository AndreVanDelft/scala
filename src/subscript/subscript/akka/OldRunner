
object SubScriptActor {
  
  private lazy val vm: CommonScriptExecutor = {
    val _vm = ScriptExecutorFactory.createScriptExecutor(true);
    
    _parallelScript()(_vm.anchorNode)
    _vm addHandler synchMsgHandler
    
    new Thread {override def run = {_vm.run}}.start()
    while (parallelOp == null) wait()
    
    _vm
  }
  private var parallelOp: CallGraphParentNodeTrait = null
  
  private object Stopper {
    def block   = synchronized(wait())
    def release = synchronized(notify())
  }
  private def script parallelScript = {*Stopper.block*} & {captureParallelOp(here)}
  private def captureParallelOp(here: CallGraphTreeNode) = synchronized {
    parallelOp = here.parent.asInstanceOf[CallGraphParentNodeTrait]
    notify()
  }
  
  val synchMsgHandler: PartialFunction[CallGraphMessage[_ <: CallGraphNodeTrait], Unit] = {
    case SynchronizationMessage(_, lock) => lock.synchronized(lock.notify())
  }
    
  def executeScript(script: Script[Unit]) = synchronized {
    val template = getScriptTemplate(script)
    vm.invokeFromET { vm.activateFrom(parallelOp, template) }
  }
  
  def releaseVm() = Stopper.release
  
}